= 변수
== 변수란?
변수란 단 하나의 값을 저장할 수 있는 메모리 공간을 의미한다.

=== 변수의 선언과 초기화

image::8.png[]

=== 변수의 명명 규칙
* 대소문자가 구분되며 길이에 제한이 없다.
* https://www.w3schools.com/java/java_ref_keywords.asp[예약어] 는 사용할 수 없다.
* 숫자로 시작할 수 없다.
* 특수문자는 '_', '$'만 가능하다.

== 변수의 타입
변수의 타입은 크게 *기본형* 과 *참조형* 두 가지로 나눌 수 있다.

xref:primitive-type[기본형]:: 실제 값을 저장한다. 논리형, 문자형, 정수형, 실수형으로, 총 8가지.
참조형:: 어떤 값이 저장되어 있는 주소를 저장한다. 기본형 타입을 제외한 나머지 타입. 참조형 변수를 선언할 때는 변수의 타입으로 `클래스의 이름` 을 사용한다.

[#primitive-type]
=== 기본형 변수
[%autowidth, cols="^,^,^,^"]
|===
|구분 |타입 |크기 |저장 가능한 값의 범위

|논리형
|boolean
|1 byte
|true, false

|xref:primitive-char[문자형]
|char
|2 byte
|0 ~ 65536 (stem:[0] ~ stem:[2^{16}-1])

1.4+.^|xref:primitive-integer[정수형]
|byte
|1 byte
|-128 ~ 127 (stem:[-2^7] ~ stem:[2^7-1])

|short
|2 byte
|-32,768 ~ 32,767 (stem:[-2^15] ~ stem:[2^15-1])

|int
|4 byte
|-2,147,483,648 ~ 2,147,483,647 (stem:[-2^31] ~ stem:[2^32-1])

|long
|8 byte
|-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 (stem:[-2^63] ~ stem:[2^63-1])

1.2+.^|xref:primitive-float[실수형]
|float
|4 byte
|stem:[1.4] x stem:[10^{-45}] ~ stem:[3.4] x stem:[10^{38}], stem:[-1.4] x stem:[10^{-45}] ~ stem:[-3.4] x stem:[10^{38}]
|double
|8 byte
|stem:[4.9] x stem:[10^{-324}] ~ stem:[1.8] x stem:[10^{308}], stem:[-4.9] x stem:[10^{-324}] ~ stem:[-1.8] x stem:[10^{308}]

|===

[#primitive-char]
==== 문자형
* `char` 타입의 변수는 단 하나의 문자 만을 저장할 수 있다.
* `char` 타입은 2 byte(=16 bit)를 표현할 수 있는데, 유니코드 값은 모두 양수 이므로, stem:[0  ~ 2^{16}-1(65536)]의 값을 가진다.
* 내부적으로는 문자가 아닌, _문자의 유니코드(정수)_ 로 인코딩되어 저장되기 때문에, 문자 리터럴 대신 문자의 유니코드를 직접 저장할 수도 있다. 다음은 같은 의미이다.

    char c = 'A';
    char ch = 65;

* 정수형 중, `short` 타입도 2 byte이다. 다음은 둘 다 똑같은 2진수로 저장된다.
** 그렇다면, 이 변수의 값을 사용 해야할 때, 이게 'A'인지, 65인지 어떻게 판단할 수 있을까?
** 값 만으로는 값을 해석할 수 없고, 타입까지 알아야 올바르게 해석할 수 있다.

    char c = 'A'; // 0000000001000001
    short s = 65; // 0000000001000001

[#primitive-integer]
==== 정수형
* 모든 정수형은 양수, 음수로 이루어져 있기 때문에, 첫 번째 비트를 `부호` 를 나타내기 위해 사용하고, 나머지는 값을 나타낸다.
** 그러므로, n 비트로 표현할 수 있는 값의 범위는 stem:[-2^{n-1}] ~ stem:[2^{n-1}-1] 이다. 양수에서 1를 빼는 이유는 `0` 이 포함되기 때문이다.
* JVM의 피연산자 스택(operand stack)은 피연산자를 4 byte 단위로 저장하기 때문에, `byte, short` 의 값을 처리할 때는 4 byte로 변환하여 연산이 수행된다. 오히려 `int` 를 사용하는 것이 더 효율적이다.
* 연산과정에서 해당 타입이 표현할 수 있는 값의 범위를 넘어서는 것을 *오버플로우(overflow)* 라고 한다. `byte` 가 표현할 수 있는 최대 값인 127을 넘어서면, 128이 아닌 -128, 즉 `byte` 가 표현할 수 있는 최소 값이 되는 걸 볼 수 있는데, 이는 음수를 표현하기 위해 *2의 보수법* 을 사용하고 있기 때문이다.

image::1.png[]

* *n의 보수* 는 더했을 때 n이 되는 수를 말하며, 2의 보수는 더했을 때 2가 되는 수, 즉 이진수로 봤을 때 자리 올림이 발생하고 0이 되는 수를 의미한다. 서로 2의 보수 관계에 있는 두 2진수로 10진수의 양수와 음수를 표현하는 것을 *2의 보수법* 이라고 한다.
** 2의 보수를 구하는 것은, 1의 보수 즉, 0을 1로 1을 0으로 바꾼 뒤, 1을 더하면 된다.

image::2.png[]

[#primitive-float]
==== 실수형
* 실수형은 값을 부동소수점수(floating-point)의 형태로 저장한다. 부동소수점수는 부호, 지수, 가수 세 부분으로 되어있다.

image::3.png[]
====
부호부(S)::
* 양수일 때는 0, 음수일 때는 1
지수부(E)::
* -127~128 까지의 값을 저장할 수 있는데, IEEE754footnote:[IEEE 754는 전기 전자 기술자 협회(IEEE)에서 개발한 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준이다.] 형식에서 사용하는 바이어스 상수, 8비트에서는 127을 더해 표현한다. 즉, 00000000 은 -127을 의미한다.
** 바이어스 상수는 n비트에서 stem:[2^{n-1}-1] 로 계산한다.
* -127 또는 128 인 경우는 특수한 목적으로 예약되어있기 때문에, 실제로 사용가능한 지수의 범위는 -126~127이다.
가수부(M)::
* 실제 값이 저장된다.
* 정규화 결과 유효숫자의 첫째 자리는 언제나 1이기 때문에 생략하고 소수 부분만 표현한다.
====

부동소수점수로 표현:: 10진수의 실수를 부동소수점수로 표현하는 방법은 다음과 같다

image::4.png[]

[%hardbreaks]
① 정수 부분은 일반적인 10진수에서 2진수로 변환하는 방법을 사용한다.
② 실수 부분은 실수 부분이 0이 될 때까지 2를 곱한 뒤, 곱한 결과의 정수 부분을 순서대로 적는다.
③ ①과 ②의 결과를 합친다.
④ ③의 결과에서 소수점을 왼쪽으로 이동시켜, 왼쪽에는 1만 남게 만든다. (끝이 없을 수도 있다) 이것을 정규화된 부동소수점수 라고 한다. 1을 제외하고 나머지 실수 부분을 가수부에 넣는다.
⑤ ④ 에서 가져온 지수 즉, 6에 바이어스 상수 127를 더한 뒤, 지수부에 넣는다.

부동소수점의 오차와 정밀도::
실수의 경우, 10진수에서 2진수로 변환할 때 무한 소수가 될 수도 있다. 이 때 가수부는 저장할 수 있는 자리수가 정해져있으므로 이 과정에서 오차가 발생하게 된다. `float` 기준에서, stem:[2^{-23}], 즉 stem:[10^{-7}] 의 최대오차가 발생하게 되는데, 이 때문에 `float` 타입의 정밀도는 7자리라고 하는 것이다. `double` 타입은 15자리의 정밀도를 가지기 때문에, 7자리 이상의 정밀도가 필요하다면 `double` 타입을 사용하면 된다.

[,java]
----
float  f = 1.1234567890f;
double d = 1.1234567890;

System.out.println(f);
System.out.println(d);
----
[]
----
1.1234568 <.>
1.123456789 <.>
----
<.> float의 경우 7자리의 정밀도를 가지고 있으므로, 8번째 자리에서 반올림이 생겨 마지막 자리가 7에서 8로 변환되었다.
<.> double의 경우 15자리의 정밀도를 가지기 때문에 15자리까지는 정확하게 값을 저장했다.

=== 상수와 리터럴
상수(Constant)::
변수처럼 값을 저장할 수 있지만 초기화될 때 한 번 저장되면 변경할 수 없다. `final` 키워드를 붙여 만들 수 있다.
리터럴(Literal)::
그 자체로 값을 의미하는 것으로 일반적인 상수의 개념이다. 다만 자바에서는 상수를 (한 번 저장하면 변경할 수 없는) 변수로 규정했기 때문에, 상수는 리터럴이라고 부른다.

== 타입 변환
형변환(casting)::
변수 또는 상수의 타입을 다른 타입으로 변환하는 것으로, boolean을 제외한 나머지 기본형들은 서로 형변환이 가능하다.

=== 정수형의 형변환
* 큰 타입에서 작은 타입으로 변환하는 경우, 크기에 따라 값 손실이 발생하거나 오버플로우가 발생하여 음수가 될 수 있다.

image::5.png[]

* 작은 타입에서 큰 타입으로 변환하는 경우에는 빈 공간이 0 또는 1로 채워진다. 음수일 경우에는 (MSB가 1일 경우) 1로 채워지는데 이는 부호를 유지하기 위함이다.

=== 실수형의 형변환
* 큰 타입인 double 타입에서 작은 타입인 float 타입으로 변환하는 경우, 정수형과 마찬가지로 크기에 따라 값 손실이 발생한다.
** 지수부는 double 타입의 바이어스 상수인 1023을 뺀 뒤, float 타입의 바이어스 상수인 127을 더해준다.
** 가수부는 52 자리 중, 앞의 23자리만 저장하고 나머지는 버린다. 이 때, 24번째 자리에서 반올림한다.
** float 타입의 범위를 넘는 값을 float로 형변환하게 되면 무한대(Infinity) 또는 0이 된다.
* 작은 타입인 float 타입에서 큰 타입인 double 타입으로 변환하는 경우에는 정수형과 마찬가지로 값 손실이 발생하지 않는다.
** 지수부는 float 타입의 바이어스 상수인 127을 뺀 뒤, double 타입의 바이어스 상수인 1023을 더해준다.
** 가수부는 23자리 이후를 0으로 채워 52자리를 맞춘다.

[,java]
----
double d = 9.12345678901234;
float f = (float)d; // 9.123457 <.>

double d = 1.0e100; // 1.0 x 10^100 <.>
float f = (float)d; // Infinity
d = 1.0e-50;        // 1.0 x 10^-50
float f = (float)d; // 0.0
----
<.> float가 나타낼 수 있는 정밀도는 7자리 이므로, 형변환 되면서 값 손실이 발생했다.
<.> float가 나타낼 수 있는 범위를 넘기 때문에, Infinity 또는 0.0이 되었다.

=== 정수형과 실수형 간의 형변환
* 정수형을 실수형으로 변환하는 경우, 실수형이 정수형보다 훨씬 큰 저장범위를 갖지만, 정밀도 때문에 오차가 발생할 수 있다. int 타입의 경우 최대 10자리, long 타입의 경우 최대 19자리의 정밀도를 요구하는데, 정밀도가 작은 타입의 실수로 변환할 경우 값이 달라질 수 있다.

image::6.png[]

* 실수형을 정수형으로 변환할 경우, 실수형의 소수점 이하 값은 반올림되는게 아니라 버려진다.

=== 자동 형변환
* 기존의 값을 최대한 보존할 수 있는 타입인 경우 자동 형변환의 대상이 되어 형변환을 생략할 수 있고, 컴파일러가 자동으로 추가해준다. 반대의 경우에는 반드시 형변환을 명시해야 한다.

[,java]
----
char c1 = 'A';
int i = c; // 자동 형변환
char c2 = (char) i;
----

== 참고 및 출처
* http://www.kyobobook.co.kr/product/detailViewKor.laf?mallGb=KOR&ejkGb=KOR&barcode=9788994492032[책 - Java의 정석]
* http://www.kyobobook.co.kr/product/detailViewKor.laf?ejkGb=KOR&mallGb=KOR&barcode=9788968481475&orderClick=LAG&Kc=[책 - 이것이 자바다]
* https://ko.wikipedia.org/wiki/%EB%B6%80%EB%8F%99%EC%86%8C%EC%88%98%EC%A0%90[위키백과 - 부동소수점]
